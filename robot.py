from typing import Tuple 
import numpy as np
from map import Map

odometryDataPointType = Tuple[float, float] # delta x, delta y

# Class implementing the sensor feedback interface for feeding into the planner.
class Robot:
  def __init__(self, startX: float, startY: float):
    self.odometry = []
  
  # As it is expensive to simulate the movement of the robot directly, we assume that the robot can reach the way point
  # generated by the planner, and generate some form of odometry while travelling there. Gaussian noise is then added for
  # robustness 
  def addToOdometryWithGaussianNoise(self, startPoint: Tuple[float, float], endPoint: Tuple[float, float], variance = 0.05):
    dx = endPoint[0] - startPoint[0] + np.random.normal(0, variance)
    dy = endPoint[1] - startPoint[1] + np.random.normal(0, variance)
    self.odometry.append(dx, dy)

  def getLidarReadingImage(self, x: int, y: int, map: Map) -> np.ndarray:
    pass

  def plotOdometryOnLidarReadingImage(self, lidarReadingImage: np.ndarray) -> np.ndarray:
    pass

  def getFeedbackImage(self, map: Map):
    pass

# Class implementating the low level controller, which will be used to control the robot to follow the waypoints. This 
# is not used in training (the simulated odometry with gaussian noise is used instead), but will be useful in evaluation
class RobotController:
  def __init__(self, robot: Robot, robotStartX: float, robotStartY: float, updateRate: int):
    self.robot = robot
    self.robotX = robotStartX,
    self.robotY = robotStartY
    self.updateRate = updateRate
    self.waypoints = []

  def addWaypoint(self, waypoint: Tuple[float, float]):
    pass

  def getControlInputs(self) -> Tuple[float, float]:
    pass

  # Moves the robot in the map based on the control inputs it generate (with added gaussian noise) and the updateRate, 
  # and updates the robot's odometry accordingly (also with added gaussian noise)
  def moveRobot(self):
    pass