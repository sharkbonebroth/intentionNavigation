from typing import Tuple, List
import numpy as np
from map import Map
from scipy import ndimage
import math

odometryDataPointType = Tuple[float, float] # delta x, delta y
MAPSCALE = 0.05 # each pixel is 0.05m

# Class implementing the sensor feedback interface for feeding into the planner.
class Robot:
  def __init__(self, startX: float, startY: float):
    self.odometry = [(startX,startY)]
    self.curr_pos = (startX,startY) #keep track of robot current position
  
  # As it is expensive to simulate the movement of the robot directly, we assume that the robot can reach the way point
  # generated by the planner, and generate some form of odometry while travelling there. Gaussian noise is then added for
  # robustness 
  def addToOdometryWithGaussianNoise(self, startPoint: Tuple[float, float], endPoint: Tuple[float, float], variance = 0.05):
    dx = endPoint[0] - startPoint[0] + np.random.normal(0, variance)
    dy = endPoint[1] - startPoint[1] + np.random.normal(0, variance)
    self.odometry.append(dx, dy)

  #return lidar image in robot frame, with robot at the center
  def getLidarReadingImage(self, coord, map: Map) -> np.ndarray:
    x, y = coord[0], coord[1]
    lidar_range = math.floor(5/MAPSCALE) #5m vision range
    lidar_image = np.zeros([lidar_range,lidar_range])
    '''
    TO DO: technically, once a FOV is blocked by obstacle, any pixel behind it should be UNKNOWN instead.
    '''
    for i in range (y-lidar_range,y+lidar_range+1):
      for j in range(x-lidar_range,x+lidar_range+1):
        if ((i==y) and (j==x)) : continue
        lidar_image[i][j] = map[i][j]
    return lidar_image

  #get the latest n odometry points, where last entry is Robot.curr_pos
  def getOdometry(self, n: int) -> List[(int,int)]:
    return self.odometry[len(self.odometry)-n:]

  def plotOdometryOnLidarReadingImage(self, lidarReadingImage: np.ndarray) -> np.ndarray:
    h, w = lidarReadingImage.shape[:2]
    odom = self.getOdometry(20)
    lidar_odom_image = lidarReadingImage.copy()
    for i in range(len(odom)):
      x, y = odom[i]
      if not ((0<=x<w) and (0<=y<h)): continue
      lidar_odom_image[y][x][0] = 255 #odom is plotted with (255,0,0): RED
    return lidar_odom_image
  
  def move(self, action):
    '''
    TO DO:
    #movement function, update curr_pos and append to self.odometry
    #call self.addToOdometryWithGaussianNoise
    '''
    pass

  #infer robot current heading based on odometry
  def getHeading(self):
    curr_x, curr_y = self.odometry[-1]
    prev_x, prev_y = self.odometry[len(self.odometry)-2] #one step before current step
    dx, dy = curr_x-prev_x , curr_y-prev_y
    heading_unit_vector = (dx,dy) / np.linalg.norm((dx,dy))
    dot_product_x = np.dot(heading_unit_vector, (1,0)) #dot product with x-axis
    angle = np.arccos(dot_product_x)*(180/math.pi) #angle the robot makes w.r.t x-axis, degree
    return angle
  
  #rotate an image by angle about center of the image
  def rotateImage(angle, I:np.ndarray) -> np.ndarray:
    h, w = I.shape[:2]
    center = w//2, h//2
    return ndimage.rotate(I,angle,reshape=True)

  def getFeedbackImage(self, map: Map):
    angle = self.getHeading()
    lidar_image = self.getLidarReadingImage(self.curr_pos,map)
    lidar_odom_image = self.plotOdometryOnLidarReadingImage(lidar_image)
    return self.rotateImage(lidar_odom_image, -angle) #rotate in opposite direction to robot's heading

# Class implementating the low level controller, which will be used to control the robot to follow the waypoints. This 
# is not used in training (the simulated odometry with gaussian noise is used instead), but will be useful in evaluation
class RobotController:
  def __init__(self, robot: Robot, robotStartX: float, robotStartY: float, updateRate: int):
    self.robot = robot
    self.robotX = robotStartX,
    self.robotY = robotStartY
    self.updateRate = updateRate
    self.waypoints = []

  def addWaypoint(self, waypoint: Tuple[float, float]):
    pass

  def getControlInputs(self) -> Tuple[float, float]:
    pass

  # Moves the robot in the map based on the control inputs it generate (with added gaussian noise) and the updateRate, 
  # and updates the robot's odometry accordingly (also with added gaussian noise)
  def moveRobot(self):
    pass